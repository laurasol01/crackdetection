# Enkel og stabil road crack/pothole detection (uten fancy greier)
# Krav: pip install ultralytics opencv-python numpy

from ultralytics import YOLO
import cv2, numpy as np, os

# === KONFIG ===
MODEL_PATH = r"C:\Users\laur\Desktop\best.pt"
VIDEO_PATH = r"C:\Users\laur\Desktop\Rangoon Road.mp4.mp4"   # Ã‰n .mp4
OUT_VIDEO  = r"C:\Users\laur\Desktop\output_potholes_simple1.mp4"

CONF_THR = 0.45     # Ã˜k hvis for mange falske treff, senk hvis den mister sprekker
IOU_THR  = 0.50
MASK_THR = 0.50     # terskel for seg-masker
FRAME_SKIP = 0      # 0 = prosesser hvert frame; 2 = hvert 3. frame
SHOW_WINDOW = True  # sett False hvis du ikke vil ha visning

# === SJEKK STIER ===
assert os.path.exists(MODEL_PATH), f"Modell ikke funnet: {MODEL_PATH}"
assert os.path.exists(VIDEO_PATH), f"Video ikke funnet:  {VIDEO_PATH}"
print("Sjekker stier:")
print("  Modell finnes? ", os.path.exists(MODEL_PATH))
print("  Video finnes?  ", os.path.exists(VIDEO_PATH))

# === LAST MODELL ===
model = YOLO(MODEL_PATH)
print("Klasser:", model.names)

# === Ã…PNE VIDEO ===
cap = cv2.VideoCapture(VIDEO_PATH)
if not cap.isOpened():
    raise RuntimeError(f"Kunne ikke Ã¥pne videofil: {VIDEO_PATH}")

fps = cap.get(cv2.CAP_PROP_FPS)
fps = fps if fps and fps > 1 else 25.0
ok, frame0 = cap.read()
if not ok:
    raise RuntimeError("Klarte ikke lese fÃ¸rste frame fra videoen.")
H0, W0 = frame0.shape[:2]
fourcc = cv2.VideoWriter_fourcc(*"mp4v")
writer = cv2.VideoWriter(OUT_VIDEO, fourcc, fps, (W0, H0))
cap.set(cv2.CAP_PROP_POS_FRAMES, 0)

frame_id = 0
while True:
    ok, img = cap.read()
    if not ok:
        print("ðŸŽ¥ Ferdig â€“ ingen flere bilder i videoen.")
        break

    frame_id += 1
    if FRAME_SKIP > 0 and (frame_id % (FRAME_SKIP + 1) != 0):
        # Skriv originalframe videre for jevn video
        writer.write(img)
        if SHOW_WINDOW:
            cv2.imshow("potholes", img)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        continue

    # YOLO inferens â€“ be om retina_masks for best mulig stÃ¸rrelse
    results = model.predict(img, conf=CONF_THR, iou=IOU_THR,
                            retina_masks=True, verbose=False)

    # Tegn direkte pÃ¥ en kopi
    vis = img.copy()

    for r in results:
        if r.masks is None or len(r.masks.data) == 0:
            continue

        mnp = r.masks.data.cpu().numpy()  # (N,H,W)
        for seg in mnp:
            # binÃ¦r maske
            m = (seg > MASK_THR).astype(np.uint8)

            # sikker: resize til frame-stÃ¸rrelse hvis nÃ¸dvendig
            if m.shape[:2] != (H0, W0):
                m = cv2.resize(m, (W0, H0), interpolation=cv2.INTER_NEAREST)

            # finn konturer
            cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            if not cnts:
                continue

            # tegn fyll (semi-transparens) + konturlinje
            overlay = vis.copy()
            cv2.drawContours(overlay, cnts, -1, (0, 0, 255), thickness=cv2.FILLED)
            cv2.drawContours(vis,    cnts, -1, (0, 0, 255), thickness=2)
            vis = cv2.addWeighted(overlay, 0.25, vis, 0.75, 0)

            # tegn enkel bbox fra masken
            ys, xs = np.where(m > 0)
            if len(xs) > 0:
                x1, y1, x2, y2 = int(xs.min()), int(ys.min()), int(xs.max()), int(ys.max())
                cv2.rectangle(vis, (x1,y1), (x2,y2), (0,255,0), 2)
                cv2.putText(vis, "crack", (x1, max(20, y1-5)),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)

    writer.write(vis)

    if SHOW_WINDOW:
        cv2.imshow("potholes", vis)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            print("Avslutter pÃ¥ 'q'.")
            break

cap.release()
writer.release()
if SHOW_WINDOW:
    cv2.destroyAllWindows()
print("âœ… Lagret video:", OUT_VIDEO)

